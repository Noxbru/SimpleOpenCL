#summary Description and library use instructions. v0.08

= Manual = 
(under construction)

<wiki:toc max_depth="2" />

= Introduction =

This section will describe the behaviour and the expected use of each function in the library, and introduce the two main data types: sclHard and sclSoft.

= SimpleOpenCL types =

In order to ease the use of OpenCL objects, SimpleOpenCL groups them in two structs: sclSoft and sclHard.

They are conceptually intuitive. sclHard groups all the objects related to OpenCL devices (hardware), and sclSoft groups all the objects related with device code (OpenCL C).

== sclHard ==

This are the eight components of sclHard:

{{{
typedef struct {
   cl_platform_id platform;
   cl_context context;
   cl_device_id device;
   cl_command_queue queue;
   int nComputeUnits;
   unsigned long int maxPointerSize;
   int deviceType;
   int devNum;
}sclHard;
}}}

To know more about platform, context, device and queue objects take a look at the OpenCL 1.1 specification at [http://www.khronos.org/opencl/ Khronos web page].

The variables nComputeUnits, deviceType and maxPointerSize are used to avoid further query's about the number of device compute units, the device type and the maximum pointer size for this device. 

Variables nComputeUnits and deviceType are used by the SimpleOpenCL function *sclGetFastestDevice* to decide wich is provably the fastest device for executing NDRange kernels.

The variable maxPointerSize is used by the SimpleOpenCL function *_sclSmartCreateContexts* in order to decide, among other variables, whether two or more devices will share the same context or not.

The variable devNum is used to numerically identify each device according to the numerical order in the original device list generated by *sclGetAllHardware* function. That allows to print at any time that information. For instance to see the execution sequence when using more than one device at once.

== sclSoft ==

This are the three components of sclSoft:

{{{
typedef struct{
   cl_program program;
   cl_kernel kernel;
   char kernelName[98];
}sclSoft;
}}}

To know more about program and kernel objects take a look at the OpenCL 1.1 specification at [http://www.khronos.org/opencl/ Khronos web page].

The variable kernelName is used to store the name of the kernel to make possible showing it to identify from which kernel are we getting debugging information if an error occurs.

= User functions =

This are the functions that a user of SimpleOpenCL might use. They can internally call library functions that are not intended to be used outside the library, but can be used as such.

== Device memory allocation ==

This functions create buffers and manipulate them, using less arguments than OpenCL native functions, and printing the error name if an error occurs.

=== sclMalloc ===

{{{
cl_mem sclMalloc( sclHard hardware, cl_int mode, size_t size );
}}}

This function returns a buffer object. "cl_mem" is a native OpenCL data type, and is the type of the buffer object returned.

It takes as arguments the device in which the buffer will be created (clHard hardware), the OpenCL buffer mode flag (CL_MEM_READ_ONLY | CL_MEM_WRITE_ONLY | CL_MEM_READ_WRITE), and the byte size of the buffer.

=== sclMallocWrite ===

{{{
cl_mem sclMallocWrite( sclHard hardware, cl_int mode, size_t size, void* hostPointer );
}}}

=== sclWrite ===

{{{
void sclWrite( sclHard hardware, size_t size, cl_mem buffer, void* hostPointer );
}}}

=== sclRead ===

{{{
void sclRead( sclHard hardware, size_t size, cl_mem buffer, void *hostPointer );
}}}

== Getting clSoft structs ==

=== sclGetCLSoftware ===

{{{
sclSoft sclGetCLSoftware( char* path, char* name, sclHard hardware );
}}}

== Release and retain OpenCL objects ==

=== sclReleaseClSoft ===

{{{
void sclReleaseClSoft( sclSoft soft );
}}}

=== sclReleaseClHard ===

{{{
void sclReleaseClHard( sclHard hard );
}}}

== Debug functions ==

== Device execution ==

=== sclManageArgsLaunchKernel ===

{{{
cl_event sclManageArgsLaunchKernel( clHard hardware, 
                                   clSoft software, 
                                   size_t *global_work_size, 
                                   size_t *local_work_size,
                                   const char* sizesValues, 
                                   ... );
}}}

This must be the most weird function of all in the library. The functionality of this function is to execute a kernel taking the host pointers, automatically creating the device buffers, copying the data to be copied to the device, launch the kernel, wait for it to finish, read the results to be read and wait until they are completely read. Then, the host pointers to be updated with device results are updated. All that by calling a single function. Further versions will implement concurrent read/write and execution, and multi-device support.

To allow the function to know what has to be done with every argument in the variable argument field "...", sizesValues argument is passed with that information encoded in a printf style manner.

Here is an example:

We have an input variable, an output variable, and we also need a read/write __global variable and a __local variable to be used exclusively by the device.
{{{
cl_event event;
float *input;
float *output;
size_t input_size, output_size, global_size, local_size;

//get the data

input_size = DATA_SIZE * sizeof(float);
output_size = DATA_SIZE * sizeof(float);
global_size = X * sizeof(float);
local_size = BUFFER * sizeof(float);

event = sclManageArgsLaunchKernel( hardware,
                                   software,
                                   global_work_size,
                                   local_work_size,
                                   " input%r output%w global%g local%N ",
                                   input_size, input, output_size, output, global_size, local_size );
}}}
After calling that function, the variable output will be updated with the results generated by the GPU.

In the example i've put the variable names along with the %x indicators. This is not necessary, since the function only reads one character after the %.

clHard hardware is a struct generated with scl functions that contains all the necessary information of the hardware for it to be executed.

clSoft software is a struct generated with scl functions that contains all the necessary information of the OpenCL kernel for it to be executed.

global_work_size and local_work_size are two pointers that contain the work item dimensions as required by clEnqueueNDRangeKernel function. See OpenCL 1.0 or 1.1 specification available on Khronos website.

const char ptr sizesValues contains the information of what are the arguments to be read next, and what to do with them. For that purpose you should write a string containing % followed by a character that describes what is to be read and what to do. For each argument you shoud write a % + character, though, if the size of the argument is needed, the function will read two arguments with a single %.

The characters that can be used, and its meanings are shown in the following list:

*%a* => Set a non pointer argument. The function will read a size_t argument, and a void ptr argument. It is intended for non pointer arguments like int, float etc... They must be passed as pointers ( "int a" must be passed as "&a"). When writing this indicator, you should pass two arguments in this order: size_t size, void ptr argument. Variable size is the size or the argument, and "argument" is the argument to be passed itself.

*%v* => Set a cl_mem argument. The function will only read a void ptr argument and use sizeof(cl_mem) as it's size. It is intended for OpenCL buffer objects or image objects already initialized. This buffers must be managed outside this function.

*%N* => Set a __local memory argument. the function will only read a size_t argument and set it as a NULL argument. This will indicate the API that it is a _local argument with the read size.

*%w* => Set a host pointer argument to be written by the device. The function will read a "size_t size" and a "void ptr arg" argument. A cl_mem buffer will be created with "size_t size" size in write only mode. When the execution of the kernel is done, it will copy the contents of the buffer to the host pointer "void ptr arg".

*%r* => Set a host pointer argument to be read by the device. The function will read a "size_t size" and a "void ptr arg" argument. A cl_mem buffer will be created with "size_t size" size in read only mode. The contents of the host pointer "arg" will be copied to the buffer before kernel execution.

*%R* => Set a host pointer argument to be read and written by the device. The same as r and w, but the buffer will be set to read/write mode. So the contents of "arg" will be copied to the buffer before kernel execution and after that, the contents of the buffer will be copied back to the "arg" pointer.

*%g* => Set a device __global pointer to be read and written only by the device. The function will read only a "size_t size" argument. A cl_mem buffer of size "size_t size" will be created in read/write mode and set as a kernel argument. There will not be any data copy between the host and the device.

The event object returned is the kernel execution event. I use it to query the execution time of the kernel. Feel free to change the function code and return any other event.

== Event queries ==

== Queue management ==

== Kernel argument setting ==

== Hardware initialization and selection ==

= Library functions =

== Debug ==

== sclSoft creation ==

== sclHard creation ==