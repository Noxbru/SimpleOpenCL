#summary Description and use instructions for the library functions. v0.07

= Introduction =

This section will describe the functionalities and the expected use of each function in the library.

= sclManageArgsLaunchKernel =

{{{
cl_event sclManageArgsLaunchKernel( clHard hardware, 
                                   clSoft software, 
                                   size_t *global_work_size, 
                                   size_t *local_work_size,
                                   const char* sizesValues, 
                                   ... );
}}}

This must be the most weird function of all in the library. The functionality of this function is to execute a kernel taking the host pointers, automatically creating the device buffers, copying the data to be copied to the device, launch the kernel, wait for it to finish, read the results to be read and wait until they are completely read. All that by calling a single function. Further versions will implement concurrent read/write and execution, and multi-device support.

To allow the function to know what has to be done with every argument in the variable argument field "...", sizesValues argument is passed with that information encoded in a printf style manner.

Here is an example:

We have an input variable, an output variable, and we also need a read/write __global variable and a __local variable to be used exclusively by the device.
{{{
cl_event event;
float *input;
float *output;
size_t input_size, output_size, global_size, local_size;

//get the data

input_size = DATA_SIZE * sizeof(float);
output_size = DATA_SIZE * sizeof(float);
global_size = X * sizeof(float);
local_size = BUFFER * sizeof(float);

event = sclManageArgsLaunchKernel( hardware,
                                   software,
                                   global_work_size,
                                   local_work_size,
                                   " input%r output%w global%g local%N ",
                                   input_size, input, output_size, output, global_size, local_size );
}}}
After calling that function, the variable output will be updated with the results generated by the GPU.

In the example i've put the variable names along with the %x indicators. This is not necessary, since the function only reads one character after the %.

clHard hardware is a struct generated with scl functions that contains all the necessary information of the hardware for it to be executed.

clSoft software is a struct generated with scl functions that contains all the necessary information of the OpenCL kernel for it to be executed.

global_work_size and local_work_size are two pointers that contain the work item dimensions as required by clEnqueueNDRangeKernel function. See OpenCL 1.0 or 1.1 specification available on Khronos website.

const char ptr sizesValues contains the information of what are the arguments to be read next, and what to do with them. For that purpose you should write an string containing % followed by a character that describes what is to be read y what to do. For each argument you shoud write an argument, though, if the size of the argument is needed, the function will read two arguments with a single %.

The characters that can be used, and its meanings are shown in the following list:

*%a* => Set a non pointer argument. The function will read a size_t argument, and a void ptr argument. It is intended for non pointer arguments like int, float etc... They must be passed as pointers ( "int a" must be passed as "&a"). When writing this indicator, you should pass two arguments in this order: size_t size, void ptr argument. Variable size is the size or the argument, and "argument" is the argument to be passed itself.

*%v* => Set a cl_mem argument. The function will only read a void ptr argument and use sizeof(cl_mem) as it's size. It is intended for OpenCL buffer objects or image objects already initialized. This buffers must be managed outside this function.

*%N* => Set a __local memory argument. the function will only read a size_t argument and set it as a NULL argument. This will indicate the API that it is a _local argument with the read size.

*%w* => Set a host pointer argument to be written by the device. The function will read a "size_t size" and a "void ptr arg" argument. A cl_mem buffer will be created with "size_t size" size in write only mode. When the execution of the kernel is done, it will copy the contents of the buffer to the host pointer "void ptr arg".

*%r* => Set a host pointer argument to be read by the device. The function will read a "size_t size" and a "void ptr arg" argument. A cl_mem buffer will be created with "size_t size" size in read only mode. The contents of the host pointer "arg" will be copied to the buffer before kernel execution.

*%R* => Set a host pointer argument to be read and written by the device. The same as r and w, but the buffer will be set to read/write mode. So the contents of "arg" will be copied to the buffer before kernel execution and after that, the contents of the buffer will be copied back to the "arg" pointer.

*%g* => Set a device __global pointer to be read and written only by the device. The function will read only a "size_t size" argument. A cl_mem buffer of size "size_t size" will be created in read/write mode and set as a kernel argument. There will not be any data copy between the host and the device.